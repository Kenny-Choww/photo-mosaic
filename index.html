<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Photon B</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* MENU BUTTON */
        #menu-toggle {
            position: absolute; top: 20px; left: 20px; z-index: 20;
            background: rgba(10, 10, 10, 0.8); backdrop-filter: blur(5px);
            color: #00e5ff; border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 16px; border-radius: 8px; cursor: pointer;
            font-size: 20px; transition: all 0.3s ease;
        }
        
        /* MAIN PANEL */
        #main-menu {
            position: absolute; top: 80px; left: 20px; z-index: 15;
            width: 280px; background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(15px); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            opacity: 0; transform: translateY(-20px); visibility: hidden;
            transition: all 0.3s ease;
            max-height: 80vh; overflow-y: auto;
        }
        #main-menu.active { opacity: 1; transform: translateY(0); visibility: visible; }

        .section { margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 15px; }
        h3 { margin: 0 0 8px 0; font-size: 12px; text-transform: uppercase; color: #00e5ff; letter-spacing: 1px; font-weight: 600; }
        p { font-size: 11px; color: #aaa; margin: 0 0 10px 0; line-height: 1.4; }

        .upload-btn {
            display: flex; align-items: center; justify-content: center;
            width: 100%; background: #222; color: white; padding: 12px;
            border-radius: 6px; border: 1px solid #333; cursor: pointer;
            font-size: 12px; box-sizing: border-box;
        }
        input[type="file"] { display: none; }
        
        /* Actions */
        .btn-action {
            background: linear-gradient(90deg, #00e5ff, #0099ff); color: #000;
            font-weight: bold; border: none; width: 100%; padding: 12px;
            border-radius: 6px; cursor: pointer; margin-top: 5px; font-size: 12px;
        }

        /* PROGRESS BAR */
        #progress-container { margin-top: 10px; display: none; }
        #progress-bar { width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; }
        #progress-fill { height: 100%; width: 0%; background: #00e5ff; transition: width 0.1s; }
        #progress-text { font-size: 10px; color: #fff; margin-top: 4px; text-align: right; }

    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <button id="menu-toggle" onclick="toggleMenu()">☰</button>

    <div id="main-menu">
        <div class="section">
            <h3>1. Pattern Image</h3>
            <p>The main shape formed by the swarm.</p>
            <label class="upload-btn">
                Upload Pattern
                <input type="file" id="upload-pattern" accept="image/*">
            </label>
        </div>

        <div class="section">
            <h3>2. Particle Photos</h3>
            <p>Upload multiple photos.</p>
            <label class="upload-btn">
                Select Photos to Upload
                <input type="file" id="upload-photos" accept="image/*" multiple>
            </label>
            
            <div id="progress-container">
                <div id="progress-bar"><div id="progress-fill"></div></div>
                <div id="progress-text">Processing...</div>
            </div>
        </div>

        <div class="section">
            <h3>3. Controls</h3>
            <button class="btn-action" onclick="resetView()">Reset View</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- SHADERS -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        attribute float imgIndex;
        varying vec3 vColor;
        varying float vImgIndex;
        uniform float uScale;
        void main() {
            vColor = customColor;
            vImgIndex = imgIndex;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * uScale * (400.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D uAtlas;      
        uniform float uAtlasGrid;      
        uniform float uMixFactor;      
        varying vec3 vColor;           
        varying float vImgIndex;       
        void main() {
            float cols = uAtlasGrid;
            float rows = uAtlasGrid;
            float colIndex = mod(vImgIndex, cols);
            float rowIndex = floor(vImgIndex / cols);
            
            // Direct UV mapping (Top-Left Origin)
            vec2 uv = (vec2(colIndex, rowIndex) + gl_PointCoord) / vec2(cols, rows);
            vec4 texColor = texture2D(uAtlas, uv);
            
            vec2 coord = gl_PointCoord - vec2(0.5);
            if(length(coord) > 0.5) discard;
            if (texColor.a < 0.1) discard;
            
            gl_FragColor = vec4(mix(vColor, texColor.rgb, uMixFactor), 1.0);
        }
    </script>

    <script>
        function toggleMenu() {
            document.getElementById('main-menu').classList.toggle('active');
            document.getElementById('menu-toggle').innerText = document.getElementById('main-menu').classList.contains('active') ? '✕' : '☰';
        }

        // --- 1. SYSTEM CONFIG ---
        const PERFECT_CAM_Z = 300; 
        const IMAGE_SIZE = 120; // 14,400 particles
        const PARTICLE_SIZE = 6.0;
        const ATLAS_SIZE = 2048; 

        // --- 2. GLOBAL STATE ---
        // We store the current pattern image here so it persists when we update photos
        let currentPatternImage = new Image();
        currentPatternImage.crossOrigin = "Anonymous";

        // --- 3. THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 0, PERFECT_CAM_Z);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 2.0;
        controls.addEventListener('start', () => { controls.autoRotate = false; });

        // --- 4. ATLAS MANAGER ---
        class TextureAtlas {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.canvas.width = ATLAS_SIZE; 
                this.canvas.height = ATLAS_SIZE;
                this.ctx = this.canvas.getContext('2d');
                this.gridSize = 1;
                this.totalSlots = 1;
            }

            generateDefaults() {
                this.gridSize = 4; // 4x4 grid
                this.totalSlots = 16;
                const step = ATLAS_SIZE / 4;
                const colors = ['#FF5733', '#33FF57', '#3357FF', '#F333FF', '#33FFF5', '#FF33A8'];
                
                this.ctx.clearRect(0,0,ATLAS_SIZE,ATLAS_SIZE);
                for(let i=0; i<16; i++) {
                    const col = i % 4;
                    const row = Math.floor(i / 4);
                    this.ctx.fillStyle = colors[i % colors.length];
                    this.ctx.fillRect(col*step, row*step, step, step);
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 60px Arial';
                    this.ctx.textAlign='center';
                    this.ctx.fillText(i+1, col*step + step/2, row*step + step/2);
                }
                return this.updateTexture();
            }

            updateTexture() {
                const tex = new THREE.CanvasTexture(this.canvas);
                tex.flipY = false;
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                return tex;
            }

            async processPhotos(files, onProgress, onComplete) {
                const count = files.length;
                this.gridSize = Math.ceil(Math.sqrt(count));
                this.totalSlots = count;
                const step = ATLAS_SIZE / this.gridSize;
                this.ctx.clearRect(0, 0, ATLAS_SIZE, ATLAS_SIZE);
                
                for (let i = 0; i < count; i++) {
                    const file = files[i];
                    const url = URL.createObjectURL(file);
                    try {
                        const img = await this.loadImage(url);
                        const col = i % this.gridSize;
                        const row = Math.floor(i / this.gridSize);
                        this.ctx.drawImage(img, col * step, row * step, step, step);
                        img.src = ""; 
                    } catch (err) { console.error("Skipped bad image", err); } 
                    finally { URL.revokeObjectURL(url); }

                    if(onProgress) onProgress(i + 1, count);
                    if(i % 5 === 0) await new Promise(r => setTimeout(r, 10));
                }

                if(onComplete) onComplete(this.updateTexture());
            }

            loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = src;
                });
            }
        }

        const atlasManager = new TextureAtlas();
        let currentAtlasTexture = atlasManager.generateDefaults();

        // --- 5. PARTICLE SYSTEM ---
        let particleSystem, uniforms;

        // Function now uses GLOBAL currentPatternImage
        function createParticles() {
            // Safety check
            if (!currentPatternImage || currentPatternImage.width === 0) return;

            if (particleSystem) scene.remove(particleSystem);

            const canvas = document.createElement('canvas');
            canvas.width = IMAGE_SIZE; canvas.height = IMAGE_SIZE;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(currentPatternImage, 0, 0, IMAGE_SIZE, IMAGE_SIZE);
            const data = ctx.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE).data;

            const positions = [];
            const colors = [];
            const sizes = [];
            const imgIndices = [];
            const totalSlots = atlasManager.totalSlots || 1;

            for (let y = 0; y < IMAGE_SIZE; y++) {
                for (let x = 0; x < IMAGE_SIZE; x++) {
                    const i = (y * IMAGE_SIZE + x) * 4;
                    if (data[i+3] > 60) {
                        const origX = (x - IMAGE_SIZE / 2) * 1.5;
                        const origY = -(y - IMAGE_SIZE / 2) * 1.5;
                        const zDepth = (Math.random() - 0.5) * 300; 
                        const distToCam = PERFECT_CAM_Z - zDepth;
                        const ratio = distToCam / PERFECT_CAM_Z;

                        positions.push(origX * ratio, origY * ratio, zDepth);
                        colors.push(data[i]/255, data[i+1]/255, data[i+2]/255);
                        sizes.push(PARTICLE_SIZE * (Math.random()*0.5 + 0.8));
                        imgIndices.push(Math.floor(Math.random() * totalSlots));
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('imgIndex', new THREE.Float32BufferAttribute(imgIndices, 1));

            uniforms = {
                uAtlas: { value: currentAtlasTexture },
                uAtlasGrid: { value: atlasManager.gridSize },
                uScale: { value: 1.0 },
                uMixFactor: { value: 0.0 }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                vertexColors: true
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // --- 6. INITIALIZATION & EVENTS ---
        
        // 1. Create a Default Pattern programmatically
        const c = document.createElement('canvas'); c.width=100; c.height=100;
        const cx = c.getContext('2d'); cx.fillStyle='black'; cx.fillRect(0,0,100,100);
        cx.fillStyle='#00e5ff'; cx.font='80px Arial'; cx.textAlign='center'; cx.fillText('★',50,80);
        
        // 2. Set the global image and Init
        currentPatternImage.src = c.toDataURL();
        currentPatternImage.onload = () => createParticles(); // Initial build

        // --- EVENT: Pattern Upload ---
        document.getElementById('upload-pattern').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const url = URL.createObjectURL(file);
            
            // Update the global pattern image
            currentPatternImage.src = url;
            // When it loads, rebuild particles using current photos (atlas)
            currentPatternImage.onload = () => {
                createParticles();
                // We don't revoke immediately in case we need to redraw, 
                // but for memory we could draw to a hidden canvas. 
                // For simplicity, we keep the src alive.
            };
        });

        // --- EVENT: Photo Upload ---
        document.getElementById('upload-photos').addEventListener('change', async (e) => {
            if(e.target.files.length === 0) return;
            
            const files = e.target.files;
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');

            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            document.body.style.cursor = 'wait';

            await atlasManager.processPhotos(
                files, 
                (current, total) => {
                    const pct = Math.round((current/total)*100);
                    progressFill.style.width = pct + '%';
                    progressText.innerText = `Processing ${current} / ${total}`;
                },
                (newTexture) => {
                    currentAtlasTexture = newTexture;
                    if(uniforms) {
                        uniforms.uAtlas.value = currentAtlasTexture;
                        uniforms.uAtlasGrid.value = atlasManager.gridSize;
                        // Re-distribute random indices using the SAVED pattern
                        createParticles(); 
                    }
                    document.body.style.cursor = 'default';
                    setTimeout(() => { progressContainer.style.display = 'none'; }, 1000);
                }
            );
        });

        window.resetView = () => {
            controls.autoRotate = false;
            controls.reset();
            camera.position.set(0, 0, PERFECT_CAM_Z);
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (uniforms) {
                const dist = camera.position.distanceTo(new THREE.Vector3(0,0,0));
                let mix = 0;
                if(dist < 150) mix = THREE.MathUtils.mapLinear(dist, 50, 150, 1.0, 0.0);
                uniforms.uMixFactor.value = mix;
            }
            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>
